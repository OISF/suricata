// This file is automatically generated. Do not edit.

pub const SC_PACKAGE_VERSION: &[u8; 10] = b"9.0.0-dev\0";
pub type __intmax_t = ::std::os::raw::c_long;
pub type intmax_t = __intmax_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum AppProtoEnum {
    ALPROTO_UNKNOWN = 0,
    ALPROTO_FAILED = 1,
    ALPROTO_HTTP1 = 2,
    ALPROTO_FTP = 3,
    ALPROTO_SMTP = 4,
    ALPROTO_TLS = 5,
    ALPROTO_SSH = 6,
    ALPROTO_IMAP = 7,
    ALPROTO_JABBER = 8,
    ALPROTO_SMB = 9,
    ALPROTO_DCERPC = 10,
    ALPROTO_IRC = 11,
    ALPROTO_DNS = 12,
    ALPROTO_MODBUS = 13,
    ALPROTO_ENIP = 14,
    ALPROTO_DNP3 = 15,
    ALPROTO_NFS = 16,
    ALPROTO_NTP = 17,
    ALPROTO_FTPDATA = 18,
    ALPROTO_TFTP = 19,
    ALPROTO_IKE = 20,
    ALPROTO_KRB5 = 21,
    ALPROTO_QUIC = 22,
    ALPROTO_DHCP = 23,
    ALPROTO_SIP = 24,
    ALPROTO_RFB = 25,
    ALPROTO_MQTT = 26,
    ALPROTO_PGSQL = 27,
    ALPROTO_TELNET = 28,
    ALPROTO_WEBSOCKET = 29,
    ALPROTO_LDAP = 30,
    ALPROTO_DOH2 = 31,
    ALPROTO_TEMPLATE = 32,
    ALPROTO_RDP = 33,
    ALPROTO_HTTP2 = 34,
    ALPROTO_BITTORRENT_DHT = 35,
    ALPROTO_POP3 = 36,
    ALPROTO_MDNS = 37,
    ALPROTO_HTTP = 38,
    ALPROTO_MAX_STATIC = 39,
}
pub type AppProto = u16;
extern "C" {
    #[doc = " \\brief Maps the ALPROTO_*, to its string equivalent.\n\n \\param alproto App layer protocol id.\n\n \\retval String equivalent for the alproto."]
    pub fn AppProtoToString(alproto: AppProto) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn AppProtoNewProtoFromString(proto_name: *const ::std::os::raw::c_char) -> AppProto;
}
extern "C" {
    pub fn AppProtoRegisterProtoString(
        alproto: AppProto, proto_name: *const ::std::os::raw::c_char,
    );
}
pub const SC_API_VERSION: u64 = 2304;
#[doc = " Structure to define a Suricata plugin."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCPlugin_ {
    pub version: u64,
    pub suricata_version: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub plugin_version: *const ::std::os::raw::c_char,
    pub license: *const ::std::os::raw::c_char,
    pub author: *const ::std::os::raw::c_char,
    pub Init: ::std::option::Option<unsafe extern "C" fn()>,
}
#[doc = " Structure to define a Suricata plugin."]
pub type SCPlugin = SCPlugin_;
pub type SCPluginRegisterFunc = ::std::option::Option<unsafe extern "C" fn() -> *mut SCPlugin>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCCapturePlugin_ {
    pub name: *mut ::std::os::raw::c_char,
    pub Init: ::std::option::Option<
        unsafe extern "C" fn(
            args: *const ::std::os::raw::c_char,
            plugin_slot: ::std::os::raw::c_int,
            receive_slot: ::std::os::raw::c_int,
            decode_slot: ::std::os::raw::c_int,
        ),
    >,
    pub ThreadInit: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::std::os::raw::c_void,
            thread_id: ::std::os::raw::c_int,
            thread_ctx: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub ThreadDeinit: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::std::os::raw::c_void,
            thread_ctx: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub GetDefaultMode:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>,
    pub entries: SCCapturePlugin___bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCCapturePlugin___bindgen_ty_1 {
    pub tqe_next: *mut SCCapturePlugin_,
    pub tqe_prev: *mut *mut SCCapturePlugin_,
}
pub type SCCapturePlugin = SCCapturePlugin_;
extern "C" {
    pub fn SCPluginRegisterCapture(arg1: *mut SCCapturePlugin) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCAppLayerPlugin_ {
    pub name: *const ::std::os::raw::c_char,
    pub Register: ::std::option::Option<unsafe extern "C" fn()>,
    pub KeywordsRegister: ::std::option::Option<unsafe extern "C" fn()>,
    pub logname: *const ::std::os::raw::c_char,
    pub confname: *const ::std::os::raw::c_char,
    pub dir: u8,
    pub Logger: ::std::option::Option<
        unsafe extern "C" fn(
            tx: *const ::std::os::raw::c_void,
            jb: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
}
pub type SCAppLayerPlugin = SCAppLayerPlugin_;
extern "C" {
    pub fn SCPluginRegisterAppLayer(arg1: *mut SCAppLayerPlugin) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SCOutputJsonLogDirection {
    LOG_DIR_PACKET = 0,
    LOG_DIR_FLOW = 1,
    LOG_DIR_FLOW_TOCLIENT = 2,
    LOG_DIR_FLOW_TOSERVER = 3,
}
pub type EveJsonSimpleTxLogFunc = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EveJsonSimpleAppLayerLogger {
    pub LogTx: EveJsonSimpleTxLogFunc,
    pub name: *const ::std::os::raw::c_char,
}
extern "C" {
    pub fn SCEveJsonSimpleGetLogger(alproto: AppProto) -> *mut EveJsonSimpleAppLayerLogger;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EveJsonTxLoggerRegistrationData {
    pub confname: *const ::std::os::raw::c_char,
    pub logname: *const ::std::os::raw::c_char,
    pub alproto: AppProto,
    pub dir: u8,
    pub LogTx: EveJsonSimpleTxLogFunc,
}
extern "C" {
    pub fn SCOutputEvePreRegisterLogger(
        reg_data: EveJsonTxLoggerRegistrationData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCSigTablePreRegister(
        KeywordsRegister: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCDetectHelperKeywordSetCleanCString(id: u16);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DetectEngineCtx_ {
    _unused: [u8; 0],
}
pub type DetectEngineCtx = DetectEngineCtx_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Signature_ {
    _unused: [u8; 0],
}
pub type Signature = Signature_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SigMatch_ {
    _unused: [u8; 0],
}
pub type SigMatch = SigMatch_;
extern "C" {
    pub fn SCDetectBufferSetActiveList(
        de_ctx: *mut DetectEngineCtx, s: *mut Signature, list: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCDetectSignatureAddTransform(
        s: *mut Signature, transform: ::std::os::raw::c_int, options: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InspectionBuffer {
    #[doc = "< active pointer, points either to ::buf or ::orig"]
    pub inspect: *const u8,
    pub inspect_offset: u64,
    #[doc = "< size of active data. See to ::len or ::orig_len"]
    pub inspect_len: u32,
    #[doc = "< is initialized. ::inspect might be NULL if transform lead to 0 size"]
    pub initialized: bool,
    #[doc = "< DETECT_CI_FLAGS_* for use with DetectEngineContentInspection"]
    pub flags: u8,
    #[doc = "< how much is in use"]
    pub len: u32,
    pub buf: *mut u8,
    #[doc = "< size of the memory allocation"]
    pub size: u32,
    pub orig_len: u32,
    pub orig: *const u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DetectEngineThreadCtx_ {
    _unused: [u8; 0],
}
pub type DetectEngineThreadCtx = DetectEngineThreadCtx_;
extern "C" {
    pub fn SCInspectionBufferCheckAndExpand(
        buffer: *mut InspectionBuffer, min_size: u32,
    ) -> *mut u8;
}
extern "C" {
    pub fn SCInspectionBufferTruncate(buffer: *mut InspectionBuffer, buf_len: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Flow_ {
    _unused: [u8; 0],
}
pub type Flow = Flow_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SigMatchCtx_ {
    _unused: [u8; 0],
}
pub type SigMatchCtx = SigMatchCtx_;
pub type InspectionMultiBufferGetDataPtr = ::std::option::Option<
    unsafe extern "C" fn(
        det_ctx: *mut DetectEngineThreadCtx_,
        txv: *const ::std::os::raw::c_void,
        flow_flags: u8,
        local_id: u32,
        buf: *mut *const u8,
        buf_len: *mut u32,
    ) -> bool,
>;
pub type InspectionSingleBufferGetDataPtr = ::std::option::Option<
    unsafe extern "C" fn(
        txv: *const ::std::os::raw::c_void,
        flow_flags: u8,
        buf: *mut *const u8,
        buf_len: *mut u32,
    ) -> bool,
>;
#[doc = " App-layer light version of SigTableElmt"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCSigTableAppLiteElmt {
    #[doc = " keyword name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " keyword description"]
    pub desc: *const ::std::os::raw::c_char,
    #[doc = " keyword documentation url"]
    pub url: *const ::std::os::raw::c_char,
    #[doc = " flags SIGMATCH_*"]
    pub flags: u32,
    #[doc = " function callback to parse and setup keyword in rule"]
    pub Setup: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut DetectEngineCtx,
            arg2: *mut Signature,
            arg3: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " function callback to free structure allocated by setup if any"]
    pub Free: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut DetectEngineCtx, arg2: *mut ::std::os::raw::c_void),
    >,
    #[doc = " function callback to match on an app-layer transaction"]
    pub AppLayerTxMatch: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut DetectEngineThreadCtx,
            arg2: *mut Flow,
            flags: u8,
            alstate: *mut ::std::os::raw::c_void,
            txv: *mut ::std::os::raw::c_void,
            arg3: *const Signature,
            arg4: *const SigMatchCtx,
        ) -> ::std::os::raw::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCTransformTableElmt {
    pub name: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
    pub url: *const ::std::os::raw::c_char,
    pub flags: u32,
    pub Setup: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut DetectEngineCtx,
            arg2: *mut Signature,
            arg3: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub Free: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut DetectEngineCtx, arg2: *mut ::std::os::raw::c_void),
    >,
    pub Transform: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut DetectEngineThreadCtx,
            arg2: *mut InspectionBuffer,
            context: *mut ::std::os::raw::c_void,
        ),
    >,
    pub TransformValidate: ::std::option::Option<
        unsafe extern "C" fn(
            content: *const u8,
            content_len: u16,
            context: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    pub TransformId: ::std::option::Option<
        unsafe extern "C" fn(
            id_data: *mut *const u8,
            id_length: *mut u32,
            context: *mut ::std::os::raw::c_void,
        ),
    >,
}
extern "C" {
    pub fn SCDetectHelperNewKeywordId() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCDetectHelperKeywordRegister(kw: *const SCSigTableAppLiteElmt) -> u16;
}
extern "C" {
    pub fn SCDetectHelperKeywordAliasRegister(kwid: u16, alias: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SCDetectHelperBufferRegister(
        name: *const ::std::os::raw::c_char, alproto: AppProto, direction: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCDetectHelperBufferMpmRegister(
        name: *const ::std::os::raw::c_char, desc: *const ::std::os::raw::c_char,
        alproto: AppProto, direction: u8, GetData: InspectionSingleBufferGetDataPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCDetectHelperMultiBufferMpmRegister(
        name: *const ::std::os::raw::c_char, desc: *const ::std::os::raw::c_char,
        alproto: AppProto, direction: u8, GetData: InspectionMultiBufferGetDataPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCDetectHelperMultiBufferProgressMpmRegister(
        name: *const ::std::os::raw::c_char, desc: *const ::std::os::raw::c_char,
        alproto: AppProto, direction: u8, GetData: InspectionMultiBufferGetDataPtr,
        progress: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCDetectHelperTransformRegister(
        kw: *const SCTransformTableElmt,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeStateStoreItem_ {
    pub flags: u32,
    pub sid: u32,
}
pub type DeStateStoreItem = DeStateStoreItem_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeStateStore_ {
    pub store: [DeStateStoreItem; 15usize],
    pub next: *mut DeStateStore_,
}
pub type DeStateStore = DeStateStore_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DetectEngineStateDirection_ {
    #[doc = "< head of the list"]
    pub head: *mut DeStateStore,
    #[doc = "< current active store"]
    pub cur: *mut DeStateStore,
    #[doc = "< tail of the list"]
    pub tail: *mut DeStateStore,
    pub cnt: u32,
    pub filestore_cnt: u16,
    pub flags: u8,
}
pub type DetectEngineStateDirection = DetectEngineStateDirection_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DetectEngineState_ {
    pub dir_state: [DetectEngineStateDirection; 2usize],
}
pub type DetectEngineState = DetectEngineState_;
extern "C" {
    #[doc = " \\brief Frees a DetectEngineState object.\n\n \\param state DetectEngineState instance to free."]
    pub fn SCDetectEngineStateFree(state: *mut DetectEngineState);
}
extern "C" {
    pub fn SCSigMatchAppendSMToList(
        arg1: *mut DetectEngineCtx, arg2: *mut Signature, arg3: u16, arg4: *mut SigMatchCtx,
        arg5: ::std::os::raw::c_int,
    ) -> *mut SigMatch;
}
extern "C" {
    pub fn SCDetectSignatureSetAppProto(
        s: *mut Signature, alproto: AppProto,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SCError {
    SC_OK = 0,
    SC_ENOMEM = 1,
    SC_EINVAL = 2,
    SC_ELIMIT = 3,
    SC_EEXIST = 4,
    SC_ENOENT = 5,
    SC_ERR_MAX = 6,
}
#[repr(i32)]
#[doc = " \\brief The various log levels\n NOTE: when adding new level, don't forget to update SCLogMapLogLevelToSyslogLevel()\n      or it may result in logging to syslog with LOG_EMERG priority."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SCLogLevel {
    SC_LOG_NOTSET = -1,
    SC_LOG_NONE = 0,
    SC_LOG_ERROR = 1,
    SC_LOG_WARNING = 2,
    SC_LOG_NOTICE = 3,
    SC_LOG_INFO = 4,
    SC_LOG_PERF = 5,
    SC_LOG_CONFIG = 6,
    SC_LOG_DEBUG = 7,
    SC_LOG_LEVEL_MAX = 8,
}
extern "C" {
    pub fn SCLogMessage(
        arg1: SCLogLevel, arg2: *const ::std::os::raw::c_char, arg3: ::std::os::raw::c_uint,
        arg4: *const ::std::os::raw::c_char, arg5: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    ) -> SCError;
}
extern "C" {
    pub fn SCFatalErrorOnInitStatic(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SCLogGetLogLevel() -> SCLogLevel;
}
#[doc = " Structure of a configuration parameter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCConfNode_ {
    pub name: *mut ::std::os::raw::c_char,
    pub val: *mut ::std::os::raw::c_char,
    pub is_seq: ::std::os::raw::c_int,
    pub final_: ::std::os::raw::c_int,
    pub parent: *mut SCConfNode_,
    pub head: SCConfNode___bindgen_ty_1,
    pub next: SCConfNode___bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCConfNode___bindgen_ty_1 {
    pub tqh_first: *mut SCConfNode_,
    pub tqh_last: *mut *mut SCConfNode_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCConfNode___bindgen_ty_2 {
    pub tqe_next: *mut SCConfNode_,
    pub tqe_prev: *mut *mut SCConfNode_,
}
#[doc = " Structure of a configuration parameter."]
pub type SCConfNode = [u64; 8usize];
extern "C" {
    pub fn SCConfInit();
}
extern "C" {
    pub fn SCConfDeInit();
}
extern "C" {
    pub fn SCConfGetRootNode() -> *mut SCConfNode;
}
extern "C" {
    pub fn SCConfGet(
        name: *const ::std::os::raw::c_char, vptr: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfGetInt(
        name: *const ::std::os::raw::c_char, val: *mut intmax_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfGetBool(
        name: *const ::std::os::raw::c_char, val: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfGetDouble(
        name: *const ::std::os::raw::c_char, val: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfGetFloat(
        name: *const ::std::os::raw::c_char, val: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfSet(
        name: *const ::std::os::raw::c_char, val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfSetFromString(
        input: *const ::std::os::raw::c_char, final_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfSetFinal(
        name: *const ::std::os::raw::c_char, val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfDump();
}
extern "C" {
    pub fn SCConfNodeDump(node: *const SCConfNode, prefix: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn SCConfNodeNew() -> *mut SCConfNode;
}
extern "C" {
    pub fn SCConfNodeFree(arg1: *mut SCConfNode);
}
extern "C" {
    pub fn SCConfGetNode(key: *const ::std::os::raw::c_char) -> *mut SCConfNode;
}
extern "C" {
    pub fn SCConfCreateContextBackup();
}
extern "C" {
    pub fn SCConfRestoreContextBackup();
}
extern "C" {
    pub fn SCConfNodeLookupChild(
        node: *const SCConfNode, key: *const ::std::os::raw::c_char,
    ) -> *mut SCConfNode;
}
extern "C" {
    pub fn SCConfNodeLookupChildValue(
        node: *const SCConfNode, key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SCConfNodeRemove(arg1: *mut SCConfNode);
}
extern "C" {
    pub fn SCConfRegisterTests();
}
extern "C" {
    pub fn SCConfNodeChildValueIsTrue(
        node: *const SCConfNode, key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfValIsTrue(val: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfValIsFalse(val: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfNodePrune(node: *mut SCConfNode);
}
extern "C" {
    pub fn SCConfRemove(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfNodeHasChildren(node: *const SCConfNode) -> bool;
}
extern "C" {
    pub fn SCConfGetChildWithDefault(
        base: *const SCConfNode, dflt: *const SCConfNode, name: *const ::std::os::raw::c_char,
    ) -> *mut SCConfNode;
}
extern "C" {
    pub fn SCConfNodeLookupKeyValue(
        base: *const SCConfNode, key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> *mut SCConfNode;
}
extern "C" {
    pub fn SCConfGetChildValue(
        base: *const SCConfNode, name: *const ::std::os::raw::c_char,
        vptr: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfGetChildValueInt(
        base: *const SCConfNode, name: *const ::std::os::raw::c_char, val: *mut intmax_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfGetChildValueBool(
        base: *const SCConfNode, name: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfGetChildValueWithDefault(
        base: *const SCConfNode, dflt: *const SCConfNode, name: *const ::std::os::raw::c_char,
        vptr: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfGetChildValueIntWithDefault(
        base: *const SCConfNode, dflt: *const SCConfNode, name: *const ::std::os::raw::c_char,
        val: *mut intmax_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfGetChildValueBoolWithDefault(
        base: *const SCConfNode, dflt: *const SCConfNode, name: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfNodeIsSequence(node: *const SCConfNode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfSetIfaceNode(
        ifaces_node_name: *const ::std::os::raw::c_char, iface: *const ::std::os::raw::c_char,
    ) -> *mut SCConfNode;
}
extern "C" {
    pub fn SCConfSetRootAndDefaultNodes(
        ifaces_node_name: *const ::std::os::raw::c_char, iface: *const ::std::os::raw::c_char,
        if_root: *mut *mut SCConfNode, if_default: *mut *mut SCConfNode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCConfNodeGetNodeOrCreate(
        parent: *mut SCConfNode, name: *const ::std::os::raw::c_char, final_: ::std::os::raw::c_int,
    ) -> *mut SCConfNode;
}
extern "C" {
    pub fn SCConfGetFirstNode(parent: *const SCConfNode) -> *mut SCConfNode;
}
extern "C" {
    pub fn SCConfGetNextNode(node: *const SCConfNode) -> *mut SCConfNode;
}
extern "C" {
    pub fn SCConfGetValueNode(node: *const SCConfNode) -> *const ::std::os::raw::c_char;
}
pub type ProbingParserFPtr = ::std::option::Option<
    unsafe extern "C" fn(
        f: *const Flow,
        flags: u8,
        input: *const u8,
        input_len: u32,
        rdir: *mut u8,
    ) -> AppProto,
>;
extern "C" {
    #[doc = " PP registration"]
    pub fn SCAppLayerProtoDetectPPRegister(
        ipproto: u8, portstr: *const ::std::os::raw::c_char, alproto: AppProto, min_depth: u16,
        max_depth: u16, direction: u8, ProbingParser1: ProbingParserFPtr,
        ProbingParser2: ProbingParserFPtr,
    );
}
extern "C" {
    #[doc = "  \\retval bool 0 if no config was found, 1 if config was found"]
    pub fn SCAppLayerProtoDetectPPParseConfPorts(
        ipproto_name: *const ::std::os::raw::c_char, ipproto: u8,
        alproto_name: *const ::std::os::raw::c_char, alproto: AppProto, min_depth: u16,
        max_depth: u16, ProbingParserTs: ProbingParserFPtr, ProbingParserTc: ProbingParserFPtr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Registers a case-sensitive pattern for protocol detection."]
    pub fn SCAppLayerProtoDetectPMRegisterPatternCS(
        ipproto: u8, alproto: AppProto, pattern: *const ::std::os::raw::c_char, depth: u16,
        offset: u16, direction: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCAppLayerProtoDetectPMRegisterPatternCSwPP(
        ipproto: u8, alproto: AppProto, pattern: *const ::std::os::raw::c_char, depth: u16,
        offset: u16, direction: u8, PPFunc: ProbingParserFPtr, pp_min_depth: u16,
        pp_max_depth: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Registers a case-insensitive pattern for protocol detection."]
    pub fn SCAppLayerProtoDetectPMRegisterPatternCI(
        ipproto: u8, alproto: AppProto, pattern: *const ::std::os::raw::c_char, depth: u16,
        offset: u16, direction: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCAppLayerRequestProtocolTLSUpgrade(f: *mut Flow) -> bool;
}
extern "C" {
    pub fn SCAppLayerForceProtocolChange(f: *mut Flow, new_proto: AppProto);
}
extern "C" {
    #[doc = " \\brief Given a protocol name, checks if proto detection is enabled in\n        the conf file.\n\n \\param alproto Name of the app layer protocol.\n\n \\retval 1 If enabled.\n \\retval 0 If disabled."]
    pub fn SCAppLayerProtoDetectConfProtoDetectionEnabled(
        ipproto: *const ::std::os::raw::c_char, alproto: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Given a protocol name, checks if proto detection is enabled in\n        the conf file.\n\n \\param alproto Name of the app layer protocol.\n \\param default_enabled enable by default if not in the configuration file\n\n \\retval 1 If enabled.\n \\retval 0 If disabled."]
    pub fn SCAppLayerProtoDetectConfProtoDetectionEnabledDefault(
        ipproto: *const ::std::os::raw::c_char, alproto: *const ::std::os::raw::c_char,
        default_enabled: bool,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppLayerParserState_ {
    _unused: [u8; 0],
}
pub type AppLayerParserState = AppLayerParserState_;
#[doc = " \\brief Data structure to store app layer decoder events."]
pub type AppLayerDecoderEvents = AppLayerDecoderEvents_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct File_ {
    _unused: [u8; 0],
}
pub type File = File_;
extern "C" {
    #[doc = " \\brief Given a protocol name, checks if the parser is enabled in\n        the conf file.\n\n \\param alproto_name Name of the app layer protocol.\n\n \\retval 1 If enabled.\n \\retval 0 If disabled."]
    pub fn SCAppLayerParserConfParserEnabled(
        ipproto: *const ::std::os::raw::c_char, alproto_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCAppLayerParserReallocCtx(alproto: AppProto) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCAppLayerParserRegisterParserAcceptableDataDirection(
        ipproto: u8, alproto: AppProto, direction: u8,
    );
}
extern "C" {
    pub fn SCAppLayerParserRegisterLogger(ipproto: u8, alproto: AppProto);
}
extern "C" {
    pub fn SCAppLayerParserTriggerRawStreamInspection(
        f: *mut Flow, direction: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SCAppLayerParserSetStreamDepth(ipproto: u8, alproto: AppProto, stream_depth: u32);
}
extern "C" {
    pub fn SCAppLayerParserStateSetFlag(pstate: *mut AppLayerParserState, flag: u16);
}
extern "C" {
    pub fn SCAppLayerParserStateIssetFlag(pstate: *mut AppLayerParserState, flag: u16) -> u16;
}
extern "C" {
    pub fn SCAppLayerRegisterParserAlias(
        proto_name: *const ::std::os::raw::c_char, proto_alias: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCEnumCharMap_ {
    pub enum_name: *const ::std::os::raw::c_char,
    pub enum_value: ::std::os::raw::c_int,
}
pub type SCEnumCharMap = SCEnumCharMap_;
extern "C" {
    pub fn SCMapEnumNameToValue(
        arg1: *const ::std::os::raw::c_char, arg2: *mut SCEnumCharMap,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCMapEnumValueToName(
        arg1: ::std::os::raw::c_int, arg2: *mut SCEnumCharMap,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " \\brief Data structure to store app layer decoder events."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppLayerDecoderEvents_ {
    pub events: *mut u8,
    pub cnt: u8,
    pub events_buffer_size: u8,
    pub event_last_logged: u8,
}
extern "C" {
    pub fn SCAppLayerDecoderEventsSetEventRaw(sevents: *mut *mut AppLayerDecoderEvents, event: u8);
}
extern "C" {
    pub fn SCAppLayerDecoderEventsFreeEvents(events: *mut *mut AppLayerDecoderEvents);
}
extern "C" {
    pub fn SCAppLayerGetEventIdByName(
        event_name: *const ::std::os::raw::c_char, table: *mut SCEnumCharMap, event_id: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SCHTTP2MimicHttp1Request(
        arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SCFileFlowFlagsToFlags(flow_file_flags: u16, direction: u8) -> u16;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StreamingBufferConfig_ {
    pub buf_size: u32,
    #[doc = "< max concurrent memory regions. 0 means no limit."]
    pub max_regions: u16,
    #[doc = "< max gap size before a new region will be created."]
    pub region_gap: u32,
    pub Calloc: ::std::option::Option<
        unsafe extern "C" fn(n: usize, size: usize) -> *mut ::std::os::raw::c_void,
    >,
    pub Realloc: ::std::option::Option<
        unsafe extern "C" fn(
            ptr: *mut ::std::os::raw::c_void,
            orig_size: usize,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub Free:
        ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void, size: usize)>,
}
pub type StreamingBufferConfig = StreamingBufferConfig_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileContainer_ {
    pub head: *mut File,
    pub tail: *mut File,
}
pub type FileContainer = FileContainer_;
extern "C" {
    #[doc = "  \\brief Store a chunk of file data in the flow. The open \"flowfile\"\n         will be used.\n\n  \\param ffc the container\n  \\param data data chunk\n  \\param data_len data chunk len\n\n  \\retval 0 ok\n  \\retval -1 error"]
    pub fn FileAppendData(
        arg1: *mut FileContainer, sbcfg: *const StreamingBufferConfig, data: *const u8,
        data_len: u32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HttpRangeContainerBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HttpRangeContainerFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTTPContentRange {
    _unused: [u8; 0],
}
#[doc = " A structure representing a single range request :\n either skipping, buffering, or appending\n As this belongs to a flow, appending data to it is ensured to be thread-safe\n Only one block per file has the pointer to the container"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HttpRangeContainerBlock {
    #[doc = " state where we skip content"]
    pub toskip: u64,
    #[doc = " current out of order range to write into"]
    pub current: *mut HttpRangeContainerBuffer,
    #[doc = " pointer to the main file container, where to directly append data"]
    pub container: *mut HttpRangeContainerFile,
    #[doc = " file container we are owning for now"]
    pub files: *mut FileContainer,
}
extern "C" {
    pub fn SCHttpRangeFreeBlock(b: *mut HttpRangeContainerBlock);
}
extern "C" {
    pub fn SCHttpRangeContainerOpenFile(
        key: *const ::std::os::raw::c_uchar, keylen: u32, f: *const Flow,
        cr: *const HTTPContentRange, sbcfg: *const StreamingBufferConfig,
        name: *const ::std::os::raw::c_uchar, name_len: u16, flags: u16,
        data: *const ::std::os::raw::c_uchar, data_len: u32,
    ) -> *mut HttpRangeContainerBlock;
}
extern "C" {
    pub fn SCHttpRangeAppendData(
        sbcfg: *const StreamingBufferConfig, c: *mut HttpRangeContainerBlock, data: *const u8,
        len: u32,
    ) -> ::std::os::raw::c_int;
}
pub type FrameId = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Frame {
    #[doc = "< protocol specific field type. E.g. NBSS.HDR or SMB.DATA"]
    pub type_: u8,
    #[doc = "< frame flags: FRAME_FLAG_*"]
    pub flags: u8,
    pub event_cnt: u8,
    #[doc = "< per frame store for events"]
    pub events: [u8; 4usize],
    #[doc = "< offset from the start of the stream"]
    pub offset: u64,
    pub len: i64,
    pub id: i64,
    #[doc = "< tx_id to match this frame. UINT64T_MAX if not used."]
    pub tx_id: u64,
    #[doc = "< inspection tracker relative to the start of the frame"]
    pub inspect_progress: u64,
}
extern "C" {
    pub fn SCAppLayerFrameNewByRelativeOffset(
        f: *mut Flow, stream_slice: *const ::std::os::raw::c_void, frame_start_rel: u32, len: i64,
        dir: ::std::os::raw::c_int, frame_type: u8,
    ) -> *mut Frame;
}
extern "C" {
    pub fn SCAppLayerFrameAddEventById(
        f: *const Flow, dir: ::std::os::raw::c_int, id: FrameId, e: u8,
    );
}
extern "C" {
    pub fn SCAppLayerFrameSetLengthById(
        f: *const Flow, dir: ::std::os::raw::c_int, id: FrameId, len: i64,
    );
}
extern "C" {
    pub fn SCAppLayerFrameSetTxIdById(
        f: *const Flow, dir: ::std::os::raw::c_int, id: FrameId, tx_id: u64,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MpmPattern_ {
    pub len: u16,
    pub flags: u8,
    pub offset: u16,
    pub depth: u16,
    pub original_pat: *mut u8,
    pub cs: *mut u8,
    pub ci: *mut u8,
    pub id: u32,
    pub sids_size: u32,
    pub sids: *mut u32,
    pub next: *mut MpmPattern_,
}
pub type MpmPattern = MpmPattern_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MpmCtx_ {
    pub ctx: *mut ::std::os::raw::c_void,
    pub mpm_type: u8,
    pub flags: u8,
    pub maxdepth: u16,
    pub pattern_cnt: u32,
    pub minlen: u16,
    pub maxlen: u16,
    pub memory_cnt: u32,
    pub memory_size: u32,
    pub max_pat_id: u32,
    pub init_hash: *mut *mut MpmPattern,
}
pub type MpmCtx = MpmCtx_;
extern "C" {
    pub fn SCMpmAddPatternCI(
        mpm_ctx: *mut MpmCtx, pat: *const u8, patlen: u16, offset: u16, depth: u16, pid: u32,
        sid: u32, flags: u8,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GenericVar_ {
    #[doc = "< variable type, uses detection sm_type"]
    pub type_: u16,
    pub pad: [u8; 2usize],
    pub idx: u32,
    pub next: *mut GenericVar_,
}
pub type GenericVar = GenericVar_;
extern "C" {
    pub fn SCGenericVarFree(arg1: *mut GenericVar);
}
extern "C" {
    pub fn SCBasicSearchNocaseIndex(arg1: *const u8, arg2: u32, arg3: *const u8, arg4: u16) -> u32;
}
extern "C" {
    pub fn SCFlowGetLastTimeAsParts(flow: *const Flow, secs: *mut u64, usecs: *mut u64);
}
extern "C" {
    pub fn SCFlowGetFlags(flow: *const Flow) -> u32;
}
extern "C" {
    pub fn SCFlowGetSourcePort(flow: *const Flow) -> u16;
}
extern "C" {
    pub fn SCFlowGetDestinationPort(flow: *const Flow) -> u16;
}
extern "C" {
    pub fn SCSRepCatGetByShortname(shortname: *const ::std::os::raw::c_char) -> u8;
}
